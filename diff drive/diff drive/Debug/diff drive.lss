
diff drive.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000000  00800200  00800200  0000088c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000818  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000114  00800200  00800200  0000088c  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  0000088c  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  000008bc  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000001c0  00000000  00000000  000008fc  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00002062  00000000  00000000  00000abc  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000f73  00000000  00000000  00002b1e  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000ce8  00000000  00000000  00003a91  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  0000053c  00000000  00000000  0000477c  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000cd5  00000000  00000000  00004cb8  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00001448  00000000  00000000  0000598d  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000001f0  00000000  00000000  00006dd5  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	71 c0       	rjmp	.+226    	; 0xe4 <__ctors_end>
   2:	00 00       	nop
   4:	81 c0       	rjmp	.+258    	; 0x108 <__bad_interrupt>
   6:	00 00       	nop
   8:	7f c0       	rjmp	.+254    	; 0x108 <__bad_interrupt>
   a:	00 00       	nop
   c:	7d c0       	rjmp	.+250    	; 0x108 <__bad_interrupt>
   e:	00 00       	nop
  10:	7b c0       	rjmp	.+246    	; 0x108 <__bad_interrupt>
  12:	00 00       	nop
  14:	79 c0       	rjmp	.+242    	; 0x108 <__bad_interrupt>
  16:	00 00       	nop
  18:	77 c0       	rjmp	.+238    	; 0x108 <__bad_interrupt>
  1a:	00 00       	nop
  1c:	75 c0       	rjmp	.+234    	; 0x108 <__bad_interrupt>
  1e:	00 00       	nop
  20:	73 c0       	rjmp	.+230    	; 0x108 <__bad_interrupt>
  22:	00 00       	nop
  24:	71 c0       	rjmp	.+226    	; 0x108 <__bad_interrupt>
  26:	00 00       	nop
  28:	6f c0       	rjmp	.+222    	; 0x108 <__bad_interrupt>
  2a:	00 00       	nop
  2c:	6d c0       	rjmp	.+218    	; 0x108 <__bad_interrupt>
  2e:	00 00       	nop
  30:	6b c0       	rjmp	.+214    	; 0x108 <__bad_interrupt>
  32:	00 00       	nop
  34:	69 c0       	rjmp	.+210    	; 0x108 <__bad_interrupt>
  36:	00 00       	nop
  38:	67 c0       	rjmp	.+206    	; 0x108 <__bad_interrupt>
  3a:	00 00       	nop
  3c:	65 c0       	rjmp	.+202    	; 0x108 <__bad_interrupt>
  3e:	00 00       	nop
  40:	63 c0       	rjmp	.+198    	; 0x108 <__bad_interrupt>
  42:	00 00       	nop
  44:	61 c0       	rjmp	.+194    	; 0x108 <__bad_interrupt>
  46:	00 00       	nop
  48:	5f c0       	rjmp	.+190    	; 0x108 <__bad_interrupt>
  4a:	00 00       	nop
  4c:	5d c0       	rjmp	.+186    	; 0x108 <__bad_interrupt>
  4e:	00 00       	nop
  50:	5b c0       	rjmp	.+182    	; 0x108 <__bad_interrupt>
  52:	00 00       	nop
  54:	59 c0       	rjmp	.+178    	; 0x108 <__bad_interrupt>
  56:	00 00       	nop
  58:	57 c0       	rjmp	.+174    	; 0x108 <__bad_interrupt>
  5a:	00 00       	nop
  5c:	55 c0       	rjmp	.+170    	; 0x108 <__bad_interrupt>
  5e:	00 00       	nop
  60:	53 c0       	rjmp	.+166    	; 0x108 <__bad_interrupt>
  62:	00 00       	nop
  64:	1a c2       	rjmp	.+1076   	; 0x49a <__vector_25>
  66:	00 00       	nop
  68:	47 c2       	rjmp	.+1166   	; 0x4f8 <__vector_26>
  6a:	00 00       	nop
  6c:	4d c0       	rjmp	.+154    	; 0x108 <__bad_interrupt>
  6e:	00 00       	nop
  70:	4b c0       	rjmp	.+150    	; 0x108 <__bad_interrupt>
  72:	00 00       	nop
  74:	49 c0       	rjmp	.+146    	; 0x108 <__bad_interrupt>
  76:	00 00       	nop
  78:	47 c0       	rjmp	.+142    	; 0x108 <__bad_interrupt>
  7a:	00 00       	nop
  7c:	45 c0       	rjmp	.+138    	; 0x108 <__bad_interrupt>
  7e:	00 00       	nop
  80:	43 c0       	rjmp	.+134    	; 0x108 <__bad_interrupt>
  82:	00 00       	nop
  84:	41 c0       	rjmp	.+130    	; 0x108 <__bad_interrupt>
  86:	00 00       	nop
  88:	3f c0       	rjmp	.+126    	; 0x108 <__bad_interrupt>
  8a:	00 00       	nop
  8c:	3d c0       	rjmp	.+122    	; 0x108 <__bad_interrupt>
  8e:	00 00       	nop
  90:	61 c2       	rjmp	.+1218   	; 0x554 <__vector_36>
  92:	00 00       	nop
  94:	8e c2       	rjmp	.+1308   	; 0x5b2 <__vector_37>
  96:	00 00       	nop
  98:	37 c0       	rjmp	.+110    	; 0x108 <__bad_interrupt>
  9a:	00 00       	nop
  9c:	35 c0       	rjmp	.+106    	; 0x108 <__bad_interrupt>
  9e:	00 00       	nop
  a0:	33 c0       	rjmp	.+102    	; 0x108 <__bad_interrupt>
  a2:	00 00       	nop
  a4:	31 c0       	rjmp	.+98     	; 0x108 <__bad_interrupt>
  a6:	00 00       	nop
  a8:	2f c0       	rjmp	.+94     	; 0x108 <__bad_interrupt>
  aa:	00 00       	nop
  ac:	2d c0       	rjmp	.+90     	; 0x108 <__bad_interrupt>
  ae:	00 00       	nop
  b0:	2b c0       	rjmp	.+86     	; 0x108 <__bad_interrupt>
  b2:	00 00       	nop
  b4:	29 c0       	rjmp	.+82     	; 0x108 <__bad_interrupt>
  b6:	00 00       	nop
  b8:	27 c0       	rjmp	.+78     	; 0x108 <__bad_interrupt>
  ba:	00 00       	nop
  bc:	25 c0       	rjmp	.+74     	; 0x108 <__bad_interrupt>
  be:	00 00       	nop
  c0:	23 c0       	rjmp	.+70     	; 0x108 <__bad_interrupt>
  c2:	00 00       	nop
  c4:	21 c0       	rjmp	.+66     	; 0x108 <__bad_interrupt>
  c6:	00 00       	nop
  c8:	1f c0       	rjmp	.+62     	; 0x108 <__bad_interrupt>
  ca:	00 00       	nop
  cc:	a0 c2       	rjmp	.+1344   	; 0x60e <__vector_51>
  ce:	00 00       	nop
  d0:	cd c2       	rjmp	.+1434   	; 0x66c <__vector_52>
  d2:	00 00       	nop
  d4:	19 c0       	rjmp	.+50     	; 0x108 <__bad_interrupt>
  d6:	00 00       	nop
  d8:	f7 c2       	rjmp	.+1518   	; 0x6c8 <__vector_54>
  da:	00 00       	nop
  dc:	24 c3       	rjmp	.+1608   	; 0x726 <__vector_55>
  de:	00 00       	nop
  e0:	13 c0       	rjmp	.+38     	; 0x108 <__bad_interrupt>
	...

000000e4 <__ctors_end>:
  e4:	11 24       	eor	r1, r1
  e6:	1f be       	out	0x3f, r1	; 63
  e8:	cf ef       	ldi	r28, 0xFF	; 255
  ea:	d1 e2       	ldi	r29, 0x21	; 33
  ec:	de bf       	out	0x3e, r29	; 62
  ee:	cd bf       	out	0x3d, r28	; 61
  f0:	00 e0       	ldi	r16, 0x00	; 0
  f2:	0c bf       	out	0x3c, r16	; 60

000000f4 <__do_clear_bss>:
  f4:	23 e0       	ldi	r18, 0x03	; 3
  f6:	a0 e0       	ldi	r26, 0x00	; 0
  f8:	b2 e0       	ldi	r27, 0x02	; 2
  fa:	01 c0       	rjmp	.+2      	; 0xfe <.do_clear_bss_start>

000000fc <.do_clear_bss_loop>:
  fc:	1d 92       	st	X+, r1

000000fe <.do_clear_bss_start>:
  fe:	a4 31       	cpi	r26, 0x14	; 20
 100:	b2 07       	cpc	r27, r18
 102:	e1 f7       	brne	.-8      	; 0xfc <.do_clear_bss_loop>
 104:	02 d0       	rcall	.+4      	; 0x10a <main>
 106:	86 c3       	rjmp	.+1804   	; 0x814 <_exit>

00000108 <__bad_interrupt>:
 108:	7b cf       	rjmp	.-266    	; 0x0 <__vectors>

0000010a <main>:

#define MOTOR_RPM	450.0	
//Encoder e1(1);

int main(void)
{
 10a:	cf 93       	push	r28
 10c:	df 93       	push	r29
 10e:	1f 92       	push	r1
 110:	1f 92       	push	r1
 112:	cd b7       	in	r28, 0x3d	; 61
 114:	de b7       	in	r29, 0x3e	; 62
	sei();
 116:	78 94       	sei
	uart3_init(UART_BAUD_SELECT(9600,F_CPU));
 118:	87 e6       	ldi	r24, 0x67	; 103
 11a:	90 e0       	ldi	r25, 0x00	; 0
 11c:	32 d3       	rcall	.+1636   	; 0x782 <_Z10uart3_initj>
	
	Motor m1,m2;
	//e1.Initialise();
	m1.Initialise(1);
 11e:	61 e0       	ldi	r22, 0x01	; 1
 120:	ce 01       	movw	r24, r28
 122:	01 96       	adiw	r24, 0x01	; 1
 124:	ac d1       	rcall	.+856    	; 0x47e <_ZN5Motor10InitialiseEh>
	m2.Initialise(2);
 126:	62 e0       	ldi	r22, 0x02	; 2
 128:	ce 01       	movw	r24, r28
 12a:	02 96       	adiw	r24, 0x02	; 2
 12c:	a8 d1       	rcall	.+848    	; 0x47e <_ZN5Motor10InitialiseEh>
	char ch;
	int speed = 50;
 12e:	0f 2e       	mov	r0, r31
 130:	f2 e3       	ldi	r31, 0x32	; 50
 132:	ef 2e       	mov	r14, r31
    while (1) 
    {
	ch = '0';	
	ch = uart3_getc();
 134:	f1 2c       	mov	r15, r1
 136:	f0 2d       	mov	r31, r0
 138:	3d d3       	rcall	.+1658   	; 0x7b4 <_Z10uart3_getcv>
	uart3_putc(ch);
 13a:	8c 01       	movw	r16, r24
 13c:	56 d3       	rcall	.+1708   	; 0x7ea <_Z10uart3_putch>
	switch(ch)
 13e:	c8 01       	movw	r24, r16
 140:	99 27       	eor	r25, r25
 142:	8c 34       	cpi	r24, 0x4C	; 76
 144:	91 05       	cpc	r25, r1
 146:	69 f1       	breq	.+90     	; 0x1a2 <main+0x98>
 148:	38 f4       	brcc	.+14     	; 0x158 <main+0x4e>
 14a:	82 34       	cpi	r24, 0x42	; 66
 14c:	91 05       	cpc	r25, r1
 14e:	d1 f0       	breq	.+52     	; 0x184 <main+0x7a>
 150:	86 34       	cpi	r24, 0x46	; 70
 152:	91 05       	cpc	r25, r1
 154:	41 f0       	breq	.+16     	; 0x166 <main+0x5c>
 156:	f0 cf       	rjmp	.-32     	; 0x138 <main+0x2e>
 158:	82 35       	cpi	r24, 0x52	; 82
 15a:	91 05       	cpc	r25, r1
 15c:	29 f1       	breq	.+74     	; 0x1a8 <main+0x9e>
 15e:	83 35       	cpi	r24, 0x53	; 83
 160:	91 05       	cpc	r25, r1
 162:	29 f1       	breq	.+74     	; 0x1ae <main+0xa4>
	{
		case 'F':
		{
			m1.SetOcrValue(speed);
 164:	e9 cf       	rjmp	.-46     	; 0x138 <main+0x2e>
 166:	b7 01       	movw	r22, r14
 168:	ce 01       	movw	r24, r28
			m1.SetForwardDirection();
 16a:	01 96       	adiw	r24, 0x01	; 1
 16c:	4c d1       	rcall	.+664    	; 0x406 <_ZN5Motor11SetOcrValueEi>
			m2.SetOcrValue(speed);
 16e:	ce 01       	movw	r24, r28
 170:	01 96       	adiw	r24, 0x01	; 1
 172:	a6 d0       	rcall	.+332    	; 0x2c0 <_ZN5Motor19SetForwardDirectionEv>
 174:	b7 01       	movw	r22, r14
			
			m2.SetForwardDirection();
 176:	ce 01       	movw	r24, r28
 178:	02 96       	adiw	r24, 0x02	; 2
 17a:	45 d1       	rcall	.+650    	; 0x406 <_ZN5Motor11SetOcrValueEi>
			break;
 17c:	ce 01       	movw	r24, r28
		}
		case 'B':
		{
			m1.SetOcrValue(speed);
 17e:	02 96       	adiw	r24, 0x02	; 2
 180:	9f d0       	rcall	.+318    	; 0x2c0 <_ZN5Motor19SetForwardDirectionEv>
 182:	da cf       	rjmp	.-76     	; 0x138 <main+0x2e>
			m1.SetReverseDirection();
 184:	b7 01       	movw	r22, r14
 186:	ce 01       	movw	r24, r28
 188:	01 96       	adiw	r24, 0x01	; 1
 18a:	3d d1       	rcall	.+634    	; 0x406 <_ZN5Motor11SetOcrValueEi>

			m2.SetOcrValue(speed);
 18c:	ce 01       	movw	r24, r28
 18e:	01 96       	adiw	r24, 0x01	; 1
 190:	c8 d0       	rcall	.+400    	; 0x322 <_ZN5Motor19SetReverseDirectionEv>
 192:	b7 01       	movw	r22, r14
			m2.SetReverseDirection();
 194:	ce 01       	movw	r24, r28
 196:	02 96       	adiw	r24, 0x02	; 2
			break;
 198:	36 d1       	rcall	.+620    	; 0x406 <_ZN5Motor11SetOcrValueEi>
		}
		case 'L':
		{
			speed += 10;
 19a:	ce 01       	movw	r24, r28
 19c:	02 96       	adiw	r24, 0x02	; 2
 19e:	c1 d0       	rcall	.+386    	; 0x322 <_ZN5Motor19SetReverseDirectionEv>
		}
		case 'R':
		{
			speed -= 10;
 1a0:	cb cf       	rjmp	.-106    	; 0x138 <main+0x2e>
 1a2:	8a e0       	ldi	r24, 0x0A	; 10
 1a4:	e8 0e       	add	r14, r24
		}
		case 'S':
		{
			m1.StopMotor();
 1a6:	f1 1c       	adc	r15, r1
 1a8:	8a e0       	ldi	r24, 0x0A	; 10
 1aa:	e8 1a       	sub	r14, r24
 1ac:	f1 08       	sbc	r15, r1
			m2.StopMotor();
 1ae:	ce 01       	movw	r24, r28
 1b0:	01 96       	adiw	r24, 0x01	; 1
 1b2:	e8 d0       	rcall	.+464    	; 0x384 <_ZN5Motor9StopMotorEv>
 1b4:	ce 01       	movw	r24, r28
			break;
 1b6:	02 96       	adiw	r24, 0x02	; 2
 1b8:	e5 d0       	rcall	.+458    	; 0x384 <_ZN5Motor9StopMotorEv>
 1ba:	be cf       	rjmp	.-132    	; 0x138 <main+0x2e>

000001bc <_ZN5Motor7InitPWMEv>:

}

void Motor::InitPWM()
{
	if (num==1)
 1bc:	fc 01       	movw	r30, r24
 1be:	80 81       	ld	r24, Z
 1c0:	81 30       	cpi	r24, 0x01	; 1
 1c2:	f1 f4       	brne	.+60     	; 0x200 <_ZN5Motor7InitPWMEv+0x44>
	{
		OUTPUT(DD_F1);
 1c4:	e7 e0       	ldi	r30, 0x07	; 7
 1c6:	f1 e0       	ldi	r31, 0x01	; 1
 1c8:	80 81       	ld	r24, Z
 1ca:	80 64       	ori	r24, 0x40	; 64
 1cc:	80 83       	st	Z, r24
		OUTPUT(DD_B1);
 1ce:	80 81       	ld	r24, Z
 1d0:	80 68       	ori	r24, 0x80	; 128
 1d2:	80 83       	st	Z, r24

		OUTPUT(DD_PWM1);
 1d4:	ea e0       	ldi	r30, 0x0A	; 10
 1d6:	f1 e0       	ldi	r31, 0x01	; 1
 1d8:	80 81       	ld	r24, Z
 1da:	80 62       	ori	r24, 0x20	; 32
 1dc:	80 83       	st	Z, r24

		PWM_TCCRA1	|=  ( 1 << PWM_1COM1 ) | ( 1 << PWM_1WGM1 );														//
 1de:	e0 e2       	ldi	r30, 0x20	; 32
 1e0:	f1 e0       	ldi	r31, 0x01	; 1
 1e2:	80 81       	ld	r24, Z
 1e4:	8a 60       	ori	r24, 0x0A	; 10
 1e6:	80 83       	st	Z, r24
		PWM_TCCRB1	|=  ( 1 << PWM_1WGM2 ) | ( 1 << PWM_1WGM3 ) | ( 1 << PWM_1CS1);									//PRESCALAR 8
 1e8:	e1 e2       	ldi	r30, 0x21	; 33
 1ea:	f1 e0       	ldi	r31, 0x01	; 1
 1ec:	80 81       	ld	r24, Z
 1ee:	8a 61       	ori	r24, 0x1A	; 26
 1f0:	80 83       	st	Z, r24
		PWM_ICR1		 =         ICR_TOP;
 1f2:	89 ef       	ldi	r24, 0xF9	; 249
 1f4:	90 e0       	ldi	r25, 0x00	; 0
 1f6:	90 93 27 01 	sts	0x0127, r25	; 0x800127 <__TEXT_REGION_LENGTH__+0x700127>
 1fa:	80 93 26 01 	sts	0x0126, r24	; 0x800126 <__TEXT_REGION_LENGTH__+0x700126>
 1fe:	08 95       	ret
	}
	else if(num==2)
 200:	82 30       	cpi	r24, 0x02	; 2
 202:	f1 f4       	brne	.+60     	; 0x240 <_ZN5Motor7InitPWMEv+0x84>
	{
		OUTPUT(DD_F2);
 204:	e7 e0       	ldi	r30, 0x07	; 7
 206:	f1 e0       	ldi	r31, 0x01	; 1
 208:	80 81       	ld	r24, Z
 20a:	84 60       	ori	r24, 0x04	; 4
 20c:	80 83       	st	Z, r24
		OUTPUT(DD_B2);
 20e:	80 81       	ld	r24, Z
 210:	88 60       	ori	r24, 0x08	; 8
 212:	80 83       	st	Z, r24

		OUTPUT(DD_PWM2);
 214:	ea e0       	ldi	r30, 0x0A	; 10
 216:	f1 e0       	ldi	r31, 0x01	; 1
 218:	80 81       	ld	r24, Z
 21a:	88 60       	ori	r24, 0x08	; 8
 21c:	80 83       	st	Z, r24

		PWM_TCCRA2	|=  ( 1 << PWM_2COM1 ) | ( 1 << PWM_2WGM1 );														//
 21e:	e0 e2       	ldi	r30, 0x20	; 32
 220:	f1 e0       	ldi	r31, 0x01	; 1
 222:	80 81       	ld	r24, Z
 224:	82 68       	ori	r24, 0x82	; 130
 226:	80 83       	st	Z, r24
		PWM_TCCRB2	|=  ( 1 << PWM_2WGM2 ) | ( 1 << PWM_2WGM3 ) | ( 1 << PWM_2CS1);									//PRESCALAR 8
 228:	e1 e2       	ldi	r30, 0x21	; 33
 22a:	f1 e0       	ldi	r31, 0x01	; 1
 22c:	80 81       	ld	r24, Z
 22e:	8a 61       	ori	r24, 0x1A	; 26
 230:	80 83       	st	Z, r24
		PWM_ICR2		 =         ICR_TOP;
 232:	89 ef       	ldi	r24, 0xF9	; 249
 234:	90 e0       	ldi	r25, 0x00	; 0
 236:	90 93 27 01 	sts	0x0127, r25	; 0x800127 <__TEXT_REGION_LENGTH__+0x700127>
 23a:	80 93 26 01 	sts	0x0126, r24	; 0x800126 <__TEXT_REGION_LENGTH__+0x700126>
 23e:	08 95       	ret
	}
	else if(num==3)
 240:	83 30       	cpi	r24, 0x03	; 3
 242:	f1 f4       	brne	.+60     	; 0x280 <_ZN5Motor7InitPWMEv+0xc4>
	{
		OUTPUT(DD_F3);
 244:	e7 e0       	ldi	r30, 0x07	; 7
 246:	f1 e0       	ldi	r31, 0x01	; 1
 248:	80 81       	ld	r24, Z
 24a:	80 61       	ori	r24, 0x10	; 16
 24c:	80 83       	st	Z, r24
		OUTPUT(DD_B3);
 24e:	80 81       	ld	r24, Z
 250:	80 62       	ori	r24, 0x20	; 32
 252:	80 83       	st	Z, r24

		OUTPUT(DD_PWM3);
 254:	ea e0       	ldi	r30, 0x0A	; 10
 256:	f1 e0       	ldi	r31, 0x01	; 1
 258:	80 81       	ld	r24, Z
 25a:	80 61       	ori	r24, 0x10	; 16
 25c:	80 83       	st	Z, r24

		PWM_TCCRA3	|=  ( 1 << PWM_3COM1 ) | ( 1 << PWM_3WGM1 );														//
 25e:	e0 e2       	ldi	r30, 0x20	; 32
 260:	f1 e0       	ldi	r31, 0x01	; 1
 262:	80 81       	ld	r24, Z
 264:	82 62       	ori	r24, 0x22	; 34
 266:	80 83       	st	Z, r24
		PWM_TCCRB3	|=  ( 1 << PWM_3WGM2 ) | ( 1 << PWM_3WGM3 ) | ( 1 << PWM_3CS1);									//PRESCALAR 8
 268:	e1 e2       	ldi	r30, 0x21	; 33
 26a:	f1 e0       	ldi	r31, 0x01	; 1
 26c:	80 81       	ld	r24, Z
 26e:	8a 61       	ori	r24, 0x1A	; 26
 270:	80 83       	st	Z, r24
		PWM_ICR3		 =         ICR_TOP;
 272:	89 ef       	ldi	r24, 0xF9	; 249
 274:	90 e0       	ldi	r25, 0x00	; 0
 276:	90 93 27 01 	sts	0x0127, r25	; 0x800127 <__TEXT_REGION_LENGTH__+0x700127>
 27a:	80 93 26 01 	sts	0x0126, r24	; 0x800126 <__TEXT_REGION_LENGTH__+0x700126>
 27e:	08 95       	ret
	} 
	else if(num==4)
 280:	84 30       	cpi	r24, 0x04	; 4
 282:	e9 f4       	brne	.+58     	; 0x2be <_ZN5Motor7InitPWMEv+0x102>
	{
		OUTPUT(DD_F4);
 284:	e7 e0       	ldi	r30, 0x07	; 7
 286:	f1 e0       	ldi	r31, 0x01	; 1
 288:	80 81       	ld	r24, Z
 28a:	81 60       	ori	r24, 0x01	; 1
 28c:	80 83       	st	Z, r24
		OUTPUT(DD_B4);
 28e:	80 81       	ld	r24, Z
 290:	82 60       	ori	r24, 0x02	; 2
 292:	80 83       	st	Z, r24

		OUTPUT(DD_PWM4);
 294:	e1 e0       	ldi	r30, 0x01	; 1
 296:	f1 e0       	ldi	r31, 0x01	; 1
 298:	80 81       	ld	r24, Z
 29a:	88 60       	ori	r24, 0x08	; 8
 29c:	80 83       	st	Z, r24

		PWM_TCCRA4	|=  ( 1 << PWM_4COM1 ) | ( 1 << PWM_4WGM1 );														//
 29e:	e0 ea       	ldi	r30, 0xA0	; 160
 2a0:	f0 e0       	ldi	r31, 0x00	; 0
 2a2:	80 81       	ld	r24, Z
 2a4:	82 68       	ori	r24, 0x82	; 130
 2a6:	80 83       	st	Z, r24
		PWM_TCCRB4	|=  ( 1 << PWM_4WGM2 ) | ( 1 << PWM_4WGM3 ) | ( 1 << PWM_4CS1);									//PRESCALAR 8
 2a8:	e1 ea       	ldi	r30, 0xA1	; 161
 2aa:	f0 e0       	ldi	r31, 0x00	; 0
 2ac:	80 81       	ld	r24, Z
 2ae:	8a 61       	ori	r24, 0x1A	; 26
 2b0:	80 83       	st	Z, r24
		PWM_ICR4	 =         ICR_TOP;
 2b2:	89 ef       	ldi	r24, 0xF9	; 249
 2b4:	90 e0       	ldi	r25, 0x00	; 0
 2b6:	90 93 a7 00 	sts	0x00A7, r25	; 0x8000a7 <__TEXT_REGION_LENGTH__+0x7000a7>
 2ba:	80 93 a6 00 	sts	0x00A6, r24	; 0x8000a6 <__TEXT_REGION_LENGTH__+0x7000a6>
 2be:	08 95       	ret

000002c0 <_ZN5Motor19SetForwardDirectionEv>:
	
}

void Motor::SetForwardDirection()
{
	switch(num)
 2c0:	fc 01       	movw	r30, r24
 2c2:	80 81       	ld	r24, Z
 2c4:	82 30       	cpi	r24, 0x02	; 2
 2c6:	91 f0       	breq	.+36     	; 0x2ec <_ZN5Motor19SetForwardDirectionEv+0x2c>
 2c8:	18 f4       	brcc	.+6      	; 0x2d0 <_ZN5Motor19SetForwardDirectionEv+0x10>
 2ca:	81 30       	cpi	r24, 0x01	; 1
 2cc:	31 f0       	breq	.+12     	; 0x2da <_ZN5Motor19SetForwardDirectionEv+0x1a>
 2ce:	08 95       	ret
 2d0:	83 30       	cpi	r24, 0x03	; 3
 2d2:	a9 f0       	breq	.+42     	; 0x2fe <_ZN5Motor19SetForwardDirectionEv+0x3e>
 2d4:	84 30       	cpi	r24, 0x04	; 4
 2d6:	e1 f0       	breq	.+56     	; 0x310 <_ZN5Motor19SetForwardDirectionEv+0x50>
 2d8:	08 95       	ret
	{
		case 1:
			SET		(DD_F1);
 2da:	e8 e0       	ldi	r30, 0x08	; 8
 2dc:	f1 e0       	ldi	r31, 0x01	; 1
 2de:	80 81       	ld	r24, Z
 2e0:	80 64       	ori	r24, 0x40	; 64
 2e2:	80 83       	st	Z, r24
			CLEAR	(DD_B1);
 2e4:	80 81       	ld	r24, Z
 2e6:	8f 77       	andi	r24, 0x7F	; 127
 2e8:	80 83       	st	Z, r24
			break;
 2ea:	08 95       	ret
		case 2:
			SET		(DD_F2);
 2ec:	e8 e0       	ldi	r30, 0x08	; 8
 2ee:	f1 e0       	ldi	r31, 0x01	; 1
 2f0:	80 81       	ld	r24, Z
 2f2:	84 60       	ori	r24, 0x04	; 4
 2f4:	80 83       	st	Z, r24
			CLEAR	(DD_B2);
 2f6:	80 81       	ld	r24, Z
 2f8:	87 7f       	andi	r24, 0xF7	; 247
 2fa:	80 83       	st	Z, r24
			break;
 2fc:	08 95       	ret
		case 3:
			SET		(DD_F3);
 2fe:	e8 e0       	ldi	r30, 0x08	; 8
 300:	f1 e0       	ldi	r31, 0x01	; 1
 302:	80 81       	ld	r24, Z
 304:	80 61       	ori	r24, 0x10	; 16
 306:	80 83       	st	Z, r24
			CLEAR	(DD_B3);
 308:	80 81       	ld	r24, Z
 30a:	8f 7d       	andi	r24, 0xDF	; 223
 30c:	80 83       	st	Z, r24
			break;
 30e:	08 95       	ret
		case 4:
			SET		(DD_F4);
 310:	e8 e0       	ldi	r30, 0x08	; 8
 312:	f1 e0       	ldi	r31, 0x01	; 1
 314:	80 81       	ld	r24, Z
 316:	81 60       	ori	r24, 0x01	; 1
 318:	80 83       	st	Z, r24
			CLEAR	(DD_B4);
 31a:	80 81       	ld	r24, Z
 31c:	8d 7f       	andi	r24, 0xFD	; 253
 31e:	80 83       	st	Z, r24
 320:	08 95       	ret

00000322 <_ZN5Motor19SetReverseDirectionEv>:
	

}
void Motor::SetReverseDirection()
{
	switch(num)
 322:	fc 01       	movw	r30, r24
 324:	80 81       	ld	r24, Z
 326:	82 30       	cpi	r24, 0x02	; 2
 328:	91 f0       	breq	.+36     	; 0x34e <_ZN5Motor19SetReverseDirectionEv+0x2c>
 32a:	18 f4       	brcc	.+6      	; 0x332 <_ZN5Motor19SetReverseDirectionEv+0x10>
 32c:	81 30       	cpi	r24, 0x01	; 1
 32e:	31 f0       	breq	.+12     	; 0x33c <_ZN5Motor19SetReverseDirectionEv+0x1a>
 330:	08 95       	ret
 332:	83 30       	cpi	r24, 0x03	; 3
 334:	a9 f0       	breq	.+42     	; 0x360 <_ZN5Motor19SetReverseDirectionEv+0x3e>
 336:	84 30       	cpi	r24, 0x04	; 4
 338:	e1 f0       	breq	.+56     	; 0x372 <_ZN5Motor19SetReverseDirectionEv+0x50>
 33a:	08 95       	ret
	{
		case 1:
			CLEAR	(DD_F1);
 33c:	e8 e0       	ldi	r30, 0x08	; 8
 33e:	f1 e0       	ldi	r31, 0x01	; 1
 340:	80 81       	ld	r24, Z
 342:	8f 7b       	andi	r24, 0xBF	; 191
 344:	80 83       	st	Z, r24
			SET		(DD_B1);
 346:	80 81       	ld	r24, Z
 348:	80 68       	ori	r24, 0x80	; 128
 34a:	80 83       	st	Z, r24
			break;
 34c:	08 95       	ret
		case 2:
			CLEAR	(DD_F2);
 34e:	e8 e0       	ldi	r30, 0x08	; 8
 350:	f1 e0       	ldi	r31, 0x01	; 1
 352:	80 81       	ld	r24, Z
 354:	8b 7f       	andi	r24, 0xFB	; 251
 356:	80 83       	st	Z, r24
			SET		(DD_B2);
 358:	80 81       	ld	r24, Z
 35a:	88 60       	ori	r24, 0x08	; 8
 35c:	80 83       	st	Z, r24
			break;
 35e:	08 95       	ret
		case 3:
			CLEAR	(DD_F3);
 360:	e8 e0       	ldi	r30, 0x08	; 8
 362:	f1 e0       	ldi	r31, 0x01	; 1
 364:	80 81       	ld	r24, Z
 366:	8f 7e       	andi	r24, 0xEF	; 239
 368:	80 83       	st	Z, r24
			SET		(DD_B3);
 36a:	80 81       	ld	r24, Z
 36c:	80 62       	ori	r24, 0x20	; 32
 36e:	80 83       	st	Z, r24
			break;
 370:	08 95       	ret
		case 4:
			CLEAR	(DD_F4);
 372:	e8 e0       	ldi	r30, 0x08	; 8
 374:	f1 e0       	ldi	r31, 0x01	; 1
 376:	80 81       	ld	r24, Z
 378:	8e 7f       	andi	r24, 0xFE	; 254
 37a:	80 83       	st	Z, r24
			SET		(DD_B4);
 37c:	80 81       	ld	r24, Z
 37e:	82 60       	ori	r24, 0x02	; 2
 380:	80 83       	st	Z, r24
 382:	08 95       	ret

00000384 <_ZN5Motor9StopMotorEv>:

}

void Motor::StopMotor()
{
	switch(num)
 384:	fc 01       	movw	r30, r24
 386:	80 81       	ld	r24, Z
 388:	82 30       	cpi	r24, 0x02	; 2
 38a:	b1 f0       	breq	.+44     	; 0x3b8 <_ZN5Motor9StopMotorEv+0x34>
 38c:	18 f4       	brcc	.+6      	; 0x394 <_ZN5Motor9StopMotorEv+0x10>
 38e:	81 30       	cpi	r24, 0x01	; 1
 390:	31 f0       	breq	.+12     	; 0x39e <_ZN5Motor9StopMotorEv+0x1a>
 392:	08 95       	ret
 394:	83 30       	cpi	r24, 0x03	; 3
 396:	e9 f0       	breq	.+58     	; 0x3d2 <_ZN5Motor9StopMotorEv+0x4e>
 398:	84 30       	cpi	r24, 0x04	; 4
 39a:	41 f1       	breq	.+80     	; 0x3ec <_ZN5Motor9StopMotorEv+0x68>
 39c:	08 95       	ret
	{
		case 1:
			CLEAR	(DD_F1);
 39e:	e8 e0       	ldi	r30, 0x08	; 8
 3a0:	f1 e0       	ldi	r31, 0x01	; 1
 3a2:	80 81       	ld	r24, Z
 3a4:	8f 7b       	andi	r24, 0xBF	; 191
 3a6:	80 83       	st	Z, r24
			CLEAR	(DD_B1);
 3a8:	80 81       	ld	r24, Z
 3aa:	8f 77       	andi	r24, 0x7F	; 127
 3ac:	80 83       	st	Z, r24

			PWM_OCR1 = 0;
 3ae:	10 92 2d 01 	sts	0x012D, r1	; 0x80012d <__TEXT_REGION_LENGTH__+0x70012d>
 3b2:	10 92 2c 01 	sts	0x012C, r1	; 0x80012c <__TEXT_REGION_LENGTH__+0x70012c>
			break;
 3b6:	08 95       	ret
		case 2:
			CLEAR	(DD_F2);
 3b8:	e8 e0       	ldi	r30, 0x08	; 8
 3ba:	f1 e0       	ldi	r31, 0x01	; 1
 3bc:	80 81       	ld	r24, Z
 3be:	8b 7f       	andi	r24, 0xFB	; 251
 3c0:	80 83       	st	Z, r24
			CLEAR	(DD_B2);
 3c2:	80 81       	ld	r24, Z
 3c4:	87 7f       	andi	r24, 0xF7	; 247
 3c6:	80 83       	st	Z, r24

			PWM_OCR2 = 0;
 3c8:	10 92 29 01 	sts	0x0129, r1	; 0x800129 <__TEXT_REGION_LENGTH__+0x700129>
 3cc:	10 92 28 01 	sts	0x0128, r1	; 0x800128 <__TEXT_REGION_LENGTH__+0x700128>
			break;
 3d0:	08 95       	ret
		case 3:
			CLEAR	(DD_F3);
 3d2:	e8 e0       	ldi	r30, 0x08	; 8
 3d4:	f1 e0       	ldi	r31, 0x01	; 1
 3d6:	80 81       	ld	r24, Z
 3d8:	8f 7e       	andi	r24, 0xEF	; 239
 3da:	80 83       	st	Z, r24
			CLEAR	(DD_B3);
 3dc:	80 81       	ld	r24, Z
 3de:	8f 7d       	andi	r24, 0xDF	; 223
 3e0:	80 83       	st	Z, r24

			PWM_OCR3 = 0;
 3e2:	10 92 2b 01 	sts	0x012B, r1	; 0x80012b <__TEXT_REGION_LENGTH__+0x70012b>
 3e6:	10 92 2a 01 	sts	0x012A, r1	; 0x80012a <__TEXT_REGION_LENGTH__+0x70012a>
			break;
 3ea:	08 95       	ret
		case 4:
			CLEAR	(DD_F4);
 3ec:	e8 e0       	ldi	r30, 0x08	; 8
 3ee:	f1 e0       	ldi	r31, 0x01	; 1
 3f0:	80 81       	ld	r24, Z
 3f2:	8e 7f       	andi	r24, 0xFE	; 254
 3f4:	80 83       	st	Z, r24
			CLEAR	(DD_B4);
 3f6:	80 81       	ld	r24, Z
 3f8:	8d 7f       	andi	r24, 0xFD	; 253
 3fa:	80 83       	st	Z, r24

			PWM_OCR4 = 0;
 3fc:	10 92 a9 00 	sts	0x00A9, r1	; 0x8000a9 <__TEXT_REGION_LENGTH__+0x7000a9>
 400:	10 92 a8 00 	sts	0x00A8, r1	; 0x8000a8 <__TEXT_REGION_LENGTH__+0x7000a8>
 404:	08 95       	ret

00000406 <_ZN5Motor11SetOcrValueEi>:
	}
}


void Motor::SetOcrValue(int Ocr)
{
 406:	0f 93       	push	r16
 408:	1f 93       	push	r17
 40a:	cf 93       	push	r28
 40c:	df 93       	push	r29
 40e:	8c 01       	movw	r16, r24
 410:	eb 01       	movw	r28, r22
    if (Ocr > 0)
 412:	1c 16       	cp	r1, r28
 414:	1d 06       	cpc	r1, r29
        SetForwardDirection();
 416:	0c f4       	brge	.+2      	; 0x41a <_ZN5Motor11SetOcrValueEi+0x14>
	if( Ocr >= MAX_VALUE)
 418:	53 df       	rcall	.-346    	; 0x2c0 <_ZN5Motor19SetForwardDirectionEv>
 41a:	c9 3f       	cpi	r28, 0xF9	; 249
 41c:	d1 05       	cpc	r29, r1
		Ocr = MAX_VALUE;
	if( Ocr < 0)
 41e:	44 f4       	brge	.+16     	; 0x430 <_ZN5Motor11SetOcrValueEi+0x2a>
 420:	dd 23       	and	r29, r29
	{
        Ocr = -Ocr;
 422:	44 f4       	brge	.+16     	; 0x434 <_ZN5Motor11SetOcrValueEi+0x2e>
 424:	d1 95       	neg	r29
        SetReverseDirection();
 426:	c1 95       	neg	r28
 428:	d1 09       	sbc	r29, r1
 42a:	c8 01       	movw	r24, r16
void Motor::SetOcrValue(int Ocr)
{
    if (Ocr > 0)
        SetForwardDirection();
	if( Ocr >= MAX_VALUE)
		Ocr = MAX_VALUE;
 42c:	7a df       	rcall	.-268    	; 0x322 <_ZN5Motor19SetReverseDirectionEv>
 42e:	02 c0       	rjmp	.+4      	; 0x434 <_ZN5Motor11SetOcrValueEi+0x2e>
	if( Ocr < 0)
	{
        Ocr = -Ocr;
        SetReverseDirection();
	}
	switch(num)
 430:	c9 ef       	ldi	r28, 0xF9	; 249
 432:	d0 e0       	ldi	r29, 0x00	; 0
 434:	f8 01       	movw	r30, r16
 436:	80 81       	ld	r24, Z
 438:	82 30       	cpi	r24, 0x02	; 2
 43a:	71 f0       	breq	.+28     	; 0x458 <_ZN5Motor11SetOcrValueEi+0x52>
 43c:	18 f4       	brcc	.+6      	; 0x444 <_ZN5Motor11SetOcrValueEi+0x3e>
 43e:	81 30       	cpi	r24, 0x01	; 1
 440:	31 f0       	breq	.+12     	; 0x44e <_ZN5Motor11SetOcrValueEi+0x48>
 442:	18 c0       	rjmp	.+48     	; 0x474 <_ZN5Motor11SetOcrValueEi+0x6e>
 444:	83 30       	cpi	r24, 0x03	; 3
 446:	69 f0       	breq	.+26     	; 0x462 <_ZN5Motor11SetOcrValueEi+0x5c>
 448:	84 30       	cpi	r24, 0x04	; 4
	{
		case 1:
			PWM_OCR1	= Ocr;
 44a:	81 f0       	breq	.+32     	; 0x46c <_ZN5Motor11SetOcrValueEi+0x66>
 44c:	13 c0       	rjmp	.+38     	; 0x474 <_ZN5Motor11SetOcrValueEi+0x6e>
 44e:	d0 93 2d 01 	sts	0x012D, r29	; 0x80012d <__TEXT_REGION_LENGTH__+0x70012d>
			break;
 452:	c0 93 2c 01 	sts	0x012C, r28	; 0x80012c <__TEXT_REGION_LENGTH__+0x70012c>
		case 2:
			PWM_OCR2	= Ocr;
 456:	0e c0       	rjmp	.+28     	; 0x474 <_ZN5Motor11SetOcrValueEi+0x6e>
 458:	d0 93 29 01 	sts	0x0129, r29	; 0x800129 <__TEXT_REGION_LENGTH__+0x700129>
			break;
 45c:	c0 93 28 01 	sts	0x0128, r28	; 0x800128 <__TEXT_REGION_LENGTH__+0x700128>
		case 3:
			PWM_OCR3	= Ocr;
 460:	09 c0       	rjmp	.+18     	; 0x474 <_ZN5Motor11SetOcrValueEi+0x6e>
 462:	d0 93 2b 01 	sts	0x012B, r29	; 0x80012b <__TEXT_REGION_LENGTH__+0x70012b>
			break;
 466:	c0 93 2a 01 	sts	0x012A, r28	; 0x80012a <__TEXT_REGION_LENGTH__+0x70012a>
		case 4:
			PWM_OCR4	= Ocr;
 46a:	04 c0       	rjmp	.+8      	; 0x474 <_ZN5Motor11SetOcrValueEi+0x6e>
 46c:	d0 93 a9 00 	sts	0x00A9, r29	; 0x8000a9 <__TEXT_REGION_LENGTH__+0x7000a9>
			break;
	}
}
 470:	c0 93 a8 00 	sts	0x00A8, r28	; 0x8000a8 <__TEXT_REGION_LENGTH__+0x7000a8>
 474:	df 91       	pop	r29
 476:	cf 91       	pop	r28
 478:	1f 91       	pop	r17
 47a:	0f 91       	pop	r16
 47c:	08 95       	ret

0000047e <_ZN5Motor10InitialiseEh>:
#include "Motor.h"



void Motor::Initialise(uint8_t no)
{
 47e:	cf 93       	push	r28
 480:	df 93       	push	r29
 482:	ec 01       	movw	r28, r24
	num = no;
	InitPWM();

	StopMotor();
 484:	68 83       	st	Y, r22
 486:	9a de       	rcall	.-716    	; 0x1bc <_ZN5Motor7InitPWMEv>
	SetOcrValue(0);
 488:	ce 01       	movw	r24, r28
 48a:	7c df       	rcall	.-264    	; 0x384 <_ZN5Motor9StopMotorEv>
 48c:	60 e0       	ldi	r22, 0x00	; 0
 48e:	70 e0       	ldi	r23, 0x00	; 0

}
 490:	ce 01       	movw	r24, r28
 492:	b9 df       	rcall	.-142    	; 0x406 <_ZN5Motor11SetOcrValueEi>
 494:	df 91       	pop	r29
 496:	cf 91       	pop	r28
 498:	08 95       	ret

0000049a <__vector_25>:
 Input:    None
 Returns:  None
 **************************************************************************/
void uart2_flush(void)
{
	UART2_RxHead = UART2_RxTail;
 49a:	1f 92       	push	r1
 49c:	0f 92       	push	r0
 49e:	0f b6       	in	r0, 0x3f	; 63
 4a0:	0f 92       	push	r0
 4a2:	11 24       	eor	r1, r1
 4a4:	0b b6       	in	r0, 0x3b	; 59
 4a6:	0f 92       	push	r0
 4a8:	2f 93       	push	r18
 4aa:	8f 93       	push	r24
 4ac:	9f 93       	push	r25
 4ae:	ef 93       	push	r30
 4b0:	ff 93       	push	r31
 4b2:	80 91 c0 00 	lds	r24, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7000c0>
 4b6:	20 91 c6 00 	lds	r18, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7000c6>
 4ba:	88 71       	andi	r24, 0x18	; 24
 4bc:	e0 91 d1 02 	lds	r30, 0x02D1	; 0x8002d1 <_ZL12UART0_RxHead>
 4c0:	ef 5f       	subi	r30, 0xFF	; 255
 4c2:	ef 71       	andi	r30, 0x1F	; 31
 4c4:	90 91 d0 02 	lds	r25, 0x02D0	; 0x8002d0 <_ZL12UART0_RxTail>
 4c8:	e9 17       	cp	r30, r25
 4ca:	39 f0       	breq	.+14     	; 0x4da <__vector_25+0x40>
 4cc:	e0 93 d1 02 	sts	0x02D1, r30	; 0x8002d1 <_ZL12UART0_RxHead>
 4d0:	f0 e0       	ldi	r31, 0x00	; 0
 4d2:	ec 52       	subi	r30, 0x2C	; 44
 4d4:	fd 4f       	sbci	r31, 0xFD	; 253
 4d6:	20 83       	st	Z, r18
 4d8:	01 c0       	rjmp	.+2      	; 0x4dc <__vector_25+0x42>
 4da:	82 e0       	ldi	r24, 0x02	; 2
 4dc:	80 93 cf 02 	sts	0x02CF, r24	; 0x8002cf <_ZL17UART0_LastRxError>
 4e0:	ff 91       	pop	r31
 4e2:	ef 91       	pop	r30
 4e4:	9f 91       	pop	r25
 4e6:	8f 91       	pop	r24
 4e8:	2f 91       	pop	r18
 4ea:	0f 90       	pop	r0
 4ec:	0b be       	out	0x3b, r0	; 59
 4ee:	0f 90       	pop	r0
 4f0:	0f be       	out	0x3f, r0	; 63
 4f2:	0f 90       	pop	r0
 4f4:	1f 90       	pop	r1
 4f6:	18 95       	reti

000004f8 <__vector_26>:
 4f8:	1f 92       	push	r1
 4fa:	0f 92       	push	r0
 4fc:	0f b6       	in	r0, 0x3f	; 63
 4fe:	0f 92       	push	r0
 500:	11 24       	eor	r1, r1
 502:	0b b6       	in	r0, 0x3b	; 59
 504:	0f 92       	push	r0
 506:	8f 93       	push	r24
 508:	9f 93       	push	r25
 50a:	ef 93       	push	r30
 50c:	ff 93       	push	r31
 50e:	90 91 d3 02 	lds	r25, 0x02D3	; 0x8002d3 <_ZL12UART0_TxHead>
 512:	80 91 d2 02 	lds	r24, 0x02D2	; 0x8002d2 <_ZL12UART0_TxTail>
 516:	98 17       	cp	r25, r24
 518:	69 f0       	breq	.+26     	; 0x534 <__vector_26+0x3c>
 51a:	e0 91 d2 02 	lds	r30, 0x02D2	; 0x8002d2 <_ZL12UART0_TxTail>
 51e:	ef 5f       	subi	r30, 0xFF	; 255
 520:	ef 71       	andi	r30, 0x1F	; 31
 522:	e0 93 d2 02 	sts	0x02D2, r30	; 0x8002d2 <_ZL12UART0_TxTail>
 526:	f0 e0       	ldi	r31, 0x00	; 0
 528:	ec 50       	subi	r30, 0x0C	; 12
 52a:	fd 4f       	sbci	r31, 0xFD	; 253
 52c:	80 81       	ld	r24, Z
 52e:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7000c6>
 532:	05 c0       	rjmp	.+10     	; 0x53e <__vector_26+0x46>
 534:	e1 ec       	ldi	r30, 0xC1	; 193
 536:	f0 e0       	ldi	r31, 0x00	; 0
 538:	80 81       	ld	r24, Z
 53a:	8f 7d       	andi	r24, 0xDF	; 223
 53c:	80 83       	st	Z, r24
 53e:	ff 91       	pop	r31
 540:	ef 91       	pop	r30
 542:	9f 91       	pop	r25
 544:	8f 91       	pop	r24
 546:	0f 90       	pop	r0
 548:	0b be       	out	0x3b, r0	; 59
 54a:	0f 90       	pop	r0
 54c:	0f be       	out	0x3f, r0	; 63
 54e:	0f 90       	pop	r0
 550:	1f 90       	pop	r1
 552:	18 95       	reti

00000554 <__vector_36>:
 554:	1f 92       	push	r1
 556:	0f 92       	push	r0
 558:	0f b6       	in	r0, 0x3f	; 63
 55a:	0f 92       	push	r0
 55c:	11 24       	eor	r1, r1
 55e:	0b b6       	in	r0, 0x3b	; 59
 560:	0f 92       	push	r0
 562:	2f 93       	push	r18
 564:	8f 93       	push	r24
 566:	9f 93       	push	r25
 568:	ef 93       	push	r30
 56a:	ff 93       	push	r31
 56c:	80 91 c8 00 	lds	r24, 0x00C8	; 0x8000c8 <__TEXT_REGION_LENGTH__+0x7000c8>
 570:	20 91 ce 00 	lds	r18, 0x00CE	; 0x8000ce <__TEXT_REGION_LENGTH__+0x7000ce>
 574:	88 71       	andi	r24, 0x18	; 24
 576:	e0 91 8c 02 	lds	r30, 0x028C	; 0x80028c <_ZL12UART1_RxHead>
 57a:	ef 5f       	subi	r30, 0xFF	; 255
 57c:	ef 71       	andi	r30, 0x1F	; 31
 57e:	90 91 8b 02 	lds	r25, 0x028B	; 0x80028b <_ZL12UART1_RxTail>
 582:	e9 17       	cp	r30, r25
 584:	39 f0       	breq	.+14     	; 0x594 <__vector_36+0x40>
 586:	e0 93 8c 02 	sts	0x028C, r30	; 0x80028c <_ZL12UART1_RxHead>
 58a:	f0 e0       	ldi	r31, 0x00	; 0
 58c:	e1 57       	subi	r30, 0x71	; 113
 58e:	fd 4f       	sbci	r31, 0xFD	; 253
 590:	20 83       	st	Z, r18
 592:	01 c0       	rjmp	.+2      	; 0x596 <__vector_36+0x42>
 594:	82 e0       	ldi	r24, 0x02	; 2
 596:	80 93 8a 02 	sts	0x028A, r24	; 0x80028a <_ZL17UART1_LastRxError>
 59a:	ff 91       	pop	r31
 59c:	ef 91       	pop	r30
 59e:	9f 91       	pop	r25
 5a0:	8f 91       	pop	r24
 5a2:	2f 91       	pop	r18
 5a4:	0f 90       	pop	r0
 5a6:	0b be       	out	0x3b, r0	; 59
 5a8:	0f 90       	pop	r0
 5aa:	0f be       	out	0x3f, r0	; 63
 5ac:	0f 90       	pop	r0
 5ae:	1f 90       	pop	r1
 5b0:	18 95       	reti

000005b2 <__vector_37>:
 5b2:	1f 92       	push	r1
 5b4:	0f 92       	push	r0
 5b6:	0f b6       	in	r0, 0x3f	; 63
 5b8:	0f 92       	push	r0
 5ba:	11 24       	eor	r1, r1
 5bc:	0b b6       	in	r0, 0x3b	; 59
 5be:	0f 92       	push	r0
 5c0:	8f 93       	push	r24
 5c2:	9f 93       	push	r25
 5c4:	ef 93       	push	r30
 5c6:	ff 93       	push	r31
 5c8:	90 91 8e 02 	lds	r25, 0x028E	; 0x80028e <_ZL12UART1_TxHead>
 5cc:	80 91 8d 02 	lds	r24, 0x028D	; 0x80028d <_ZL12UART1_TxTail>
 5d0:	98 17       	cp	r25, r24
 5d2:	69 f0       	breq	.+26     	; 0x5ee <__vector_37+0x3c>
 5d4:	e0 91 8d 02 	lds	r30, 0x028D	; 0x80028d <_ZL12UART1_TxTail>
 5d8:	ef 5f       	subi	r30, 0xFF	; 255
 5da:	ef 71       	andi	r30, 0x1F	; 31
 5dc:	e0 93 8d 02 	sts	0x028D, r30	; 0x80028d <_ZL12UART1_TxTail>
 5e0:	f0 e0       	ldi	r31, 0x00	; 0
 5e2:	e1 55       	subi	r30, 0x51	; 81
 5e4:	fd 4f       	sbci	r31, 0xFD	; 253
 5e6:	80 81       	ld	r24, Z
 5e8:	80 93 ce 00 	sts	0x00CE, r24	; 0x8000ce <__TEXT_REGION_LENGTH__+0x7000ce>
 5ec:	05 c0       	rjmp	.+10     	; 0x5f8 <__vector_37+0x46>
 5ee:	e9 ec       	ldi	r30, 0xC9	; 201
 5f0:	f0 e0       	ldi	r31, 0x00	; 0
 5f2:	80 81       	ld	r24, Z
 5f4:	8f 7d       	andi	r24, 0xDF	; 223
 5f6:	80 83       	st	Z, r24
 5f8:	ff 91       	pop	r31
 5fa:	ef 91       	pop	r30
 5fc:	9f 91       	pop	r25
 5fe:	8f 91       	pop	r24
 600:	0f 90       	pop	r0
 602:	0b be       	out	0x3b, r0	; 59
 604:	0f 90       	pop	r0
 606:	0f be       	out	0x3f, r0	; 63
 608:	0f 90       	pop	r0
 60a:	1f 90       	pop	r1
 60c:	18 95       	reti

0000060e <__vector_51>:
 60e:	1f 92       	push	r1
 610:	0f 92       	push	r0
 612:	0f b6       	in	r0, 0x3f	; 63
 614:	0f 92       	push	r0
 616:	11 24       	eor	r1, r1
 618:	0b b6       	in	r0, 0x3b	; 59
 61a:	0f 92       	push	r0
 61c:	2f 93       	push	r18
 61e:	8f 93       	push	r24
 620:	9f 93       	push	r25
 622:	ef 93       	push	r30
 624:	ff 93       	push	r31
 626:	80 91 d0 00 	lds	r24, 0x00D0	; 0x8000d0 <__TEXT_REGION_LENGTH__+0x7000d0>
 62a:	20 91 d6 00 	lds	r18, 0x00D6	; 0x8000d6 <__TEXT_REGION_LENGTH__+0x7000d6>
 62e:	88 71       	andi	r24, 0x18	; 24
 630:	e0 91 47 02 	lds	r30, 0x0247	; 0x800247 <_ZL12UART2_RxHead>
 634:	ef 5f       	subi	r30, 0xFF	; 255
 636:	ef 71       	andi	r30, 0x1F	; 31
 638:	90 91 46 02 	lds	r25, 0x0246	; 0x800246 <_ZL12UART2_RxTail>
 63c:	e9 17       	cp	r30, r25
 63e:	39 f0       	breq	.+14     	; 0x64e <__vector_51+0x40>
 640:	e0 93 47 02 	sts	0x0247, r30	; 0x800247 <_ZL12UART2_RxHead>
 644:	f0 e0       	ldi	r31, 0x00	; 0
 646:	e6 5b       	subi	r30, 0xB6	; 182
 648:	fd 4f       	sbci	r31, 0xFD	; 253
 64a:	20 83       	st	Z, r18
 64c:	01 c0       	rjmp	.+2      	; 0x650 <__vector_51+0x42>
 64e:	82 e0       	ldi	r24, 0x02	; 2
 650:	80 93 45 02 	sts	0x0245, r24	; 0x800245 <_ZL17UART2_LastRxError>
 654:	ff 91       	pop	r31
 656:	ef 91       	pop	r30
 658:	9f 91       	pop	r25
 65a:	8f 91       	pop	r24
 65c:	2f 91       	pop	r18
 65e:	0f 90       	pop	r0
 660:	0b be       	out	0x3b, r0	; 59
 662:	0f 90       	pop	r0
 664:	0f be       	out	0x3f, r0	; 63
 666:	0f 90       	pop	r0
 668:	1f 90       	pop	r1
 66a:	18 95       	reti

0000066c <__vector_52>:
 66c:	1f 92       	push	r1
 66e:	0f 92       	push	r0
 670:	0f b6       	in	r0, 0x3f	; 63
 672:	0f 92       	push	r0
 674:	11 24       	eor	r1, r1
 676:	0b b6       	in	r0, 0x3b	; 59
 678:	0f 92       	push	r0
 67a:	8f 93       	push	r24
 67c:	9f 93       	push	r25
 67e:	ef 93       	push	r30
 680:	ff 93       	push	r31
 682:	90 91 49 02 	lds	r25, 0x0249	; 0x800249 <_ZL12UART2_TxHead>
 686:	80 91 48 02 	lds	r24, 0x0248	; 0x800248 <_ZL12UART2_TxTail>
 68a:	98 17       	cp	r25, r24
 68c:	69 f0       	breq	.+26     	; 0x6a8 <__vector_52+0x3c>
 68e:	e0 91 48 02 	lds	r30, 0x0248	; 0x800248 <_ZL12UART2_TxTail>
 692:	ef 5f       	subi	r30, 0xFF	; 255
 694:	ef 71       	andi	r30, 0x1F	; 31
 696:	e0 93 48 02 	sts	0x0248, r30	; 0x800248 <_ZL12UART2_TxTail>
 69a:	f0 e0       	ldi	r31, 0x00	; 0
 69c:	e6 59       	subi	r30, 0x96	; 150
 69e:	fd 4f       	sbci	r31, 0xFD	; 253
 6a0:	80 81       	ld	r24, Z
 6a2:	80 93 d6 00 	sts	0x00D6, r24	; 0x8000d6 <__TEXT_REGION_LENGTH__+0x7000d6>
 6a6:	05 c0       	rjmp	.+10     	; 0x6b2 <__vector_52+0x46>
 6a8:	e1 ed       	ldi	r30, 0xD1	; 209
 6aa:	f0 e0       	ldi	r31, 0x00	; 0
 6ac:	80 81       	ld	r24, Z
 6ae:	8f 7d       	andi	r24, 0xDF	; 223
 6b0:	80 83       	st	Z, r24
 6b2:	ff 91       	pop	r31
 6b4:	ef 91       	pop	r30
 6b6:	9f 91       	pop	r25
 6b8:	8f 91       	pop	r24
 6ba:	0f 90       	pop	r0
 6bc:	0b be       	out	0x3b, r0	; 59
 6be:	0f 90       	pop	r0
 6c0:	0f be       	out	0x3f, r0	; 63
 6c2:	0f 90       	pop	r0
 6c4:	1f 90       	pop	r1
 6c6:	18 95       	reti

000006c8 <__vector_54>:
ISR(UART3_RECEIVE_INTERRUPT)
/*************************************************************************
Function: UART3 Receive Complete interrupt
Purpose:  called when the UART3 has received a character
**************************************************************************/
{
 6c8:	1f 92       	push	r1
 6ca:	0f 92       	push	r0
 6cc:	0f b6       	in	r0, 0x3f	; 63
 6ce:	0f 92       	push	r0
 6d0:	11 24       	eor	r1, r1
 6d2:	0b b6       	in	r0, 0x3b	; 59
 6d4:	0f 92       	push	r0
 6d6:	2f 93       	push	r18
 6d8:	8f 93       	push	r24
 6da:	9f 93       	push	r25
 6dc:	ef 93       	push	r30
 6de:	ff 93       	push	r31
	unsigned char usr;
	unsigned char lastRxError;


	/* read UART status register and UART data register */
	usr = UART3_STATUS;
 6e0:	80 91 30 01 	lds	r24, 0x0130	; 0x800130 <__TEXT_REGION_LENGTH__+0x700130>
	data = UART3_DATA;
 6e4:	20 91 36 01 	lds	r18, 0x0136	; 0x800136 <__TEXT_REGION_LENGTH__+0x700136>
	

	/* */
	lastRxError = (usr & (_BV(FE3) | _BV(DOR3)));
 6e8:	88 71       	andi	r24, 0x18	; 24

	/* calculate buffer index */
	tmphead = (UART3_RxHead + 1) & UART_RX_BUFFER_MASK;
 6ea:	e0 91 02 02 	lds	r30, 0x0202	; 0x800202 <_ZL12UART3_RxHead>
 6ee:	ef 5f       	subi	r30, 0xFF	; 255
 6f0:	ef 71       	andi	r30, 0x1F	; 31

	if (tmphead == UART3_RxTail) {
 6f2:	90 91 01 02 	lds	r25, 0x0201	; 0x800201 <_ZL12UART3_RxTail>
 6f6:	e9 17       	cp	r30, r25
 6f8:	39 f0       	breq	.+14     	; 0x708 <__vector_54+0x40>
		/* error: receive buffer overflow */
		lastRxError = UART_BUFFER_OVERFLOW >> 8;
	}
	else {
		/* store new index */
		UART3_RxHead = tmphead;
 6fa:	e0 93 02 02 	sts	0x0202, r30	; 0x800202 <_ZL12UART3_RxHead>
		/* store received data in buffer */
		UART3_RxBuf[tmphead] = data;
 6fe:	f0 e0       	ldi	r31, 0x00	; 0
 700:	eb 5f       	subi	r30, 0xFB	; 251
 702:	fd 4f       	sbci	r31, 0xFD	; 253
 704:	20 83       	st	Z, r18
 706:	01 c0       	rjmp	.+2      	; 0x70a <__vector_54+0x42>
	/* calculate buffer index */
	tmphead = (UART3_RxHead + 1) & UART_RX_BUFFER_MASK;

	if (tmphead == UART3_RxTail) {
		/* error: receive buffer overflow */
		lastRxError = UART_BUFFER_OVERFLOW >> 8;
 708:	82 e0       	ldi	r24, 0x02	; 2
		/* store new index */
		UART3_RxHead = tmphead;
		/* store received data in buffer */
		UART3_RxBuf[tmphead] = data;
	}
	UART3_LastRxError = lastRxError;
 70a:	80 93 00 02 	sts	0x0200, r24	; 0x800200 <_edata>
}
 70e:	ff 91       	pop	r31
 710:	ef 91       	pop	r30
 712:	9f 91       	pop	r25
 714:	8f 91       	pop	r24
 716:	2f 91       	pop	r18
 718:	0f 90       	pop	r0
 71a:	0b be       	out	0x3b, r0	; 59
 71c:	0f 90       	pop	r0
 71e:	0f be       	out	0x3f, r0	; 63
 720:	0f 90       	pop	r0
 722:	1f 90       	pop	r1
 724:	18 95       	reti

00000726 <__vector_55>:
ISR(UART3_TRANSMIT_INTERRUPT)
/*************************************************************************
Function: UART3 Data Register Empty interrupt
Purpose:  called when the UART3 is ready to transmit the next byte
**************************************************************************/
{
 726:	1f 92       	push	r1
 728:	0f 92       	push	r0
 72a:	0f b6       	in	r0, 0x3f	; 63
 72c:	0f 92       	push	r0
 72e:	11 24       	eor	r1, r1
 730:	0b b6       	in	r0, 0x3b	; 59
 732:	0f 92       	push	r0
 734:	8f 93       	push	r24
 736:	9f 93       	push	r25
 738:	ef 93       	push	r30
 73a:	ff 93       	push	r31
	unsigned char tmptail;


	if (UART3_TxHead != UART3_TxTail) {
 73c:	90 91 04 02 	lds	r25, 0x0204	; 0x800204 <_ZL12UART3_TxHead>
 740:	80 91 03 02 	lds	r24, 0x0203	; 0x800203 <_ZL12UART3_TxTail>
 744:	98 17       	cp	r25, r24
 746:	69 f0       	breq	.+26     	; 0x762 <__vector_55+0x3c>
		/* calculate and store new buffer index */
		tmptail = (UART3_TxTail + 1) & UART_TX_BUFFER_MASK;
 748:	e0 91 03 02 	lds	r30, 0x0203	; 0x800203 <_ZL12UART3_TxTail>
 74c:	ef 5f       	subi	r30, 0xFF	; 255
 74e:	ef 71       	andi	r30, 0x1F	; 31
		UART3_TxTail = tmptail;
 750:	e0 93 03 02 	sts	0x0203, r30	; 0x800203 <_ZL12UART3_TxTail>
		/* get one byte from buffer and write it to UART */
		UART3_DATA = UART3_TxBuf[tmptail];  /* start transmission */
 754:	f0 e0       	ldi	r31, 0x00	; 0
 756:	eb 5d       	subi	r30, 0xDB	; 219
 758:	fd 4f       	sbci	r31, 0xFD	; 253
 75a:	80 81       	ld	r24, Z
 75c:	80 93 36 01 	sts	0x0136, r24	; 0x800136 <__TEXT_REGION_LENGTH__+0x700136>
 760:	05 c0       	rjmp	.+10     	; 0x76c <__vector_55+0x46>
	}
	else {
		/* tx buffer empty, disable UDRE interrupt */
		UART3_CONTROL &= ~_BV(UART3_UDRIE);
 762:	e1 e3       	ldi	r30, 0x31	; 49
 764:	f1 e0       	ldi	r31, 0x01	; 1
 766:	80 81       	ld	r24, Z
 768:	8f 7d       	andi	r24, 0xDF	; 223
 76a:	80 83       	st	Z, r24
	}
}
 76c:	ff 91       	pop	r31
 76e:	ef 91       	pop	r30
 770:	9f 91       	pop	r25
 772:	8f 91       	pop	r24
 774:	0f 90       	pop	r0
 776:	0b be       	out	0x3b, r0	; 59
 778:	0f 90       	pop	r0
 77a:	0f be       	out	0x3f, r0	; 63
 77c:	0f 90       	pop	r0
 77e:	1f 90       	pop	r1
 780:	18 95       	reti

00000782 <_Z10uart3_initj>:
Input:    baudrate using macro UART_BAUD_SELECT()
Returns:  none
**************************************************************************/
void uart3_init(unsigned int baudrate)
{
	UART3_TxHead = 0;
 782:	10 92 04 02 	sts	0x0204, r1	; 0x800204 <_ZL12UART3_TxHead>
	UART3_TxTail = 0;
 786:	10 92 03 02 	sts	0x0203, r1	; 0x800203 <_ZL12UART3_TxTail>
	UART3_RxHead = 0;
 78a:	10 92 02 02 	sts	0x0202, r1	; 0x800202 <_ZL12UART3_RxHead>
	UART3_RxTail = 0;
 78e:	10 92 01 02 	sts	0x0201, r1	; 0x800201 <_ZL12UART3_RxTail>


	/* Set baud rate */
	if (baudrate & 0x8000)
 792:	99 23       	and	r25, r25
 794:	24 f4       	brge	.+8      	; 0x79e <_Z10uart3_initj+0x1c>
	{
		UART3_STATUS = (3 << U2X3);  //Enable 2x speed 
 796:	26 e0       	ldi	r18, 0x06	; 6
 798:	20 93 30 01 	sts	0x0130, r18	; 0x800130 <__TEXT_REGION_LENGTH__+0x700130>
		baudrate &= ~0x8000;
 79c:	9f 77       	andi	r25, 0x7F	; 127
	}
	UBRR3H = (unsigned char)(baudrate >> 8);
 79e:	90 93 35 01 	sts	0x0135, r25	; 0x800135 <__TEXT_REGION_LENGTH__+0x700135>
	UBRR3L = (unsigned char)baudrate;
 7a2:	80 93 34 01 	sts	0x0134, r24	; 0x800134 <__TEXT_REGION_LENGTH__+0x700134>

	/* Enable USART receiver and transmitter and receive complete interrupt */
	UART3_CONTROL = _BV(RXCIE3) | (1 << RXEN3) | (1 << TXEN3);
 7a6:	88 e9       	ldi	r24, 0x98	; 152
 7a8:	80 93 31 01 	sts	0x0131, r24	; 0x800131 <__TEXT_REGION_LENGTH__+0x700131>

	/* Set frame format: asynchronous, 8data, no parity, 1-stop bit */
#ifdef URSEL3
	UCSR3C = (1 << URSEL3) | (1 << UCSZ30) | ( 1 << UCSZ31);
#else
	UCSR3C = (1 << UCSZ30) | ( 1 << UCSZ31);
 7ac:	86 e0       	ldi	r24, 0x06	; 6
 7ae:	80 93 32 01 	sts	0x0132, r24	; 0x800132 <__TEXT_REGION_LENGTH__+0x700132>
 7b2:	08 95       	ret

000007b4 <_Z10uart3_getcv>:
{
	unsigned char tmptail;
	unsigned char data;


	if (UART3_RxHead == UART3_RxTail) {
 7b4:	90 91 02 02 	lds	r25, 0x0202	; 0x800202 <_ZL12UART3_RxHead>
 7b8:	80 91 01 02 	lds	r24, 0x0201	; 0x800201 <_ZL12UART3_RxTail>
 7bc:	98 17       	cp	r25, r24
 7be:	91 f0       	breq	.+36     	; 0x7e4 <_Z10uart3_getcv+0x30>
		 return UART_NO_DATA;   /* no data available */
	}

	/* calculate /store buffer index */
	tmptail = (UART3_RxTail + 1) & UART_RX_BUFFER_MASK;
 7c0:	e0 91 01 02 	lds	r30, 0x0201	; 0x800201 <_ZL12UART3_RxTail>
 7c4:	ef 5f       	subi	r30, 0xFF	; 255
 7c6:	ef 71       	andi	r30, 0x1F	; 31
	UART3_RxTail = tmptail;
 7c8:	e0 93 01 02 	sts	0x0201, r30	; 0x800201 <_ZL12UART3_RxTail>

	/* get data from receive buffer */
	data = UART3_RxBuf[tmptail];
 7cc:	f0 e0       	ldi	r31, 0x00	; 0
 7ce:	eb 5f       	subi	r30, 0xFB	; 251
 7d0:	fd 4f       	sbci	r31, 0xFD	; 253
 7d2:	20 81       	ld	r18, Z

	return (UART3_LastRxError << 8) + data;
 7d4:	80 91 00 02 	lds	r24, 0x0200	; 0x800200 <_edata>
 7d8:	90 e0       	ldi	r25, 0x00	; 0
 7da:	98 2f       	mov	r25, r24
 7dc:	88 27       	eor	r24, r24
 7de:	82 0f       	add	r24, r18
 7e0:	91 1d       	adc	r25, r1
 7e2:	08 95       	ret
	unsigned char tmptail;
	unsigned char data;


	if (UART3_RxHead == UART3_RxTail) {
		 return UART_NO_DATA;   /* no data available */
 7e4:	80 e0       	ldi	r24, 0x00	; 0
 7e6:	91 e0       	ldi	r25, 0x01	; 1
	/* get data from receive buffer */
	data = UART3_RxBuf[tmptail];

	return (UART3_LastRxError << 8) + data;

}/* uart3_getc */
 7e8:	08 95       	ret

000007ea <_Z10uart3_putch>:
void uart3_putc(unsigned char data)
{
	unsigned char tmphead;


	tmphead = (UART3_TxHead + 1) & UART_TX_BUFFER_MASK;
 7ea:	20 91 04 02 	lds	r18, 0x0204	; 0x800204 <_ZL12UART3_TxHead>
 7ee:	2f 5f       	subi	r18, 0xFF	; 255
 7f0:	2f 71       	andi	r18, 0x1F	; 31

	while (tmphead == UART3_TxTail) {
 7f2:	90 91 03 02 	lds	r25, 0x0203	; 0x800203 <_ZL12UART3_TxTail>
 7f6:	29 17       	cp	r18, r25
 7f8:	e1 f3       	breq	.-8      	; 0x7f2 <_Z10uart3_putch+0x8>
		;/* wait for free space in buffer */
	}

	UART3_TxBuf[tmphead] = data;
 7fa:	e2 2f       	mov	r30, r18
 7fc:	f0 e0       	ldi	r31, 0x00	; 0
 7fe:	eb 5d       	subi	r30, 0xDB	; 219
 800:	fd 4f       	sbci	r31, 0xFD	; 253
 802:	80 83       	st	Z, r24
	UART3_TxHead = tmphead;
 804:	20 93 04 02 	sts	0x0204, r18	; 0x800204 <_ZL12UART3_TxHead>

	/* enable UDRE interrupt */
	UART3_CONTROL |= _BV(UART3_UDRIE);
 808:	e1 e3       	ldi	r30, 0x31	; 49
 80a:	f1 e0       	ldi	r31, 0x01	; 1
 80c:	80 81       	ld	r24, Z
 80e:	80 62       	ori	r24, 0x20	; 32
 810:	80 83       	st	Z, r24
 812:	08 95       	ret

00000814 <_exit>:
 814:	f8 94       	cli

00000816 <__stop_program>:
 816:	ff cf       	rjmp	.-2      	; 0x816 <__stop_program>
